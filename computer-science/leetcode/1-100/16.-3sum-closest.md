---
description: Medium
---

# B 16. 3Sum Closest

## Description

Given an array `nums` of _n_ integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.

**Example:**

```text
Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```

## Approach 1: Two Pointers

The two pointers pattern requires the array to be sorted. As our **BCR** is $$O(n^2)$$, the sort operation would not change the overall time complexity.

We will follow the same [_two pointers approach as for 3Sum_](3sum.md#approach-1-two-pointers), however, since the "ideal" pair may not exist, we will track the smallest absolute different between the sum and the target.

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);

        int ans = 100000;

        for (int i = 0; i < nums.length - 2; i++) {
            int num = target - nums[i];
            int sum = nums[i] + twoSumClosest(nums, i + 1, num);
            if (Math.abs(sum - target) < Math.abs(ans - target)) {
                ans = sum;
            }
        }

        return ans;
    }

    public int twoSumClosest(int[] nums, int start, int target) {

        int lo = start;
        int hi = nums.length - 1;

        int ans = 100000;

        while (lo < hi) {
            int sum = nums[lo] + nums[hi];

            if (sum == target) {
                return sum;
            } else if (sum < target) {
                lo++;
            } else {
                hi--;
            }

            if (Math.abs(sum - target) < Math.abs(ans - target)) {
                ans = sum;
            }
        }

        return ans;
    }
}
```

**Complexity Analysis**

* **Time complexity:** $$O(n^2)$$. Sorting the array takes $$O(n\log{n})$$, so overall complexity is $$O(n\log{n} + n^2)$$. This is asymptotically equivalent to $$O(n^2)$$.
* **Space complexity:** from $$O(\log{n})$$ to $$O(n)$$, depending on the implementation of the sorting algorithm.

## Approach 2: Binary Search

In the two pointers approach, we fix one number and use two pointers to enumerate pairs. Here, we fix two numbers, and use a binary search to find the third complement number.

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int ans = 100000;
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            int num = target - nums[i];
            int sum = nums[i] + twoSumClosest(nums, i + 1, num);

            if (Math.abs(sum - target) < Math.abs(ans - target)) {
                ans = sum;
            }
        }

        return ans;
    }

    public int twoSumClosest(int[] nums, int start, int target) {
        int ans = 100000;

        for (int i = start; i < nums.length - 1; i++) {
            int num = target - nums[i];

            int lo = i + 1;
            int hi = nums.length - 1;

            while (lo <= hi) {
                int mid = (lo + hi) / 2;

                if (nums[mid] < num) {
                    lo = mid + 1;
                } else if (nums[mid] > num) {
                    hi = mid - 1;
                } else {
                    return nums[i] + nums[mid];
                }

                if (Math.abs(nums[mid] - num) < Math.abs(ans - target)) {
                    ans = nums[i] + nums[mid];
                }
            }
        }

        return ans;
    }
}
```

**Complexity Analysis**

* **Time complexity:** $$O(n^2\log{n})$$. Binary search takes $$(n\log{n})$$, and we do it $$n$$ times.
* **Space complexity:** from $$O(\log{n})$$ to $$O(n)$$, depending on the implementation of the sorting algorithm.

