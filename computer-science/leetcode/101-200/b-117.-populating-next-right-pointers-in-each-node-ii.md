---
description: Medium
---

# B 117. Populating Next Right Pointers in Each Node II

## Description

## Intuition

The most intuitive solution is modified codes based on the \[\[problem 116\]\]. Only thing needs to be worried about is how to deal with `null`.

## Approach 1: BFS \(Breadth-First Search\)

### Implementation

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Queue<Node> nodes = new LinkedList<>();
        nodes.add(root);

        while (!nodes.isEmpty()) {
            int count = nodes.size();
            while (count-- > 0) {
                Node node = nodes.poll();

                if (count > 0) {
                    node.next = nodes.peek();
                }

                if (node.left != null) {
                    nodes.add(node.left);
                }

                if (node.right != null) {
                    nodes.add(node.right);
                }
            }
        }

        return root;
    }
}
```

### Complexity Analysis

* **Time complexity:** $$O(N)$$.
* **Space complexity:** $$O(N)$$.

## Approach 2: Optimized BFS

### Algorithm

Several things need to be careful:

1. `cur.next != null`
   1. `cur.left == null`
   2. `cur.left != null`
      1. `cur.left.next = cur.right` if it's not null
      2. else `cur.left.next = headOfCur.right.firstChild`
         1. `cur.right == null`
         2. `cur.right != null`
         3. `cur.right.next = headOfCur.right.firstChild`
2. `curLevel = nextLevelFirstChild` when approaching to next level.

### Implementation

```java
class Solution {
    private Node searchFirstChild(Node node) {
        while (node != null) {
            if (node.left != null) {
                return node.left;
            }

            if (node.right != null) {
                return node.right;
            }

            node = node.next;
        }

        return node;
    }

    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Node head = root;
        Node curLevel = root.left != null ? root.left : root.right;

        while (curLevel != null) {
            Node nextFirstChild = searchFirstChild(head.next);

            if (head.left != null) {
                head.left.next = head.right != null ? head.right : nextFirstChild;
            }

            if (head.right != null) {
                head.right.next = nextFirstChild;
            }

            if (head.next == null) {
                head = curLevel;
                curLevel = searchFirstChild(curLevel);
            } else {
                head = head.next;
            }
        }

        return root;
    }
}
```

### Complexity Analysis

* **Time complextiy:** $$O(N)$$.
* **Space complexity:** $$O(N)$$.

