---
description: Medium
---
# B 102. Binary Tree Level Order Traversal

## Description

## Intuition

[[How to traversal the tree]]

Level order traversal is different from the other three ways to traversal since it uses [[BFS]]
instead of [[DFS]].

## Approach 1: Recursion

### Algorithm

In the recursion, the order of visted nodes is the same as same, but we could change the its
position in the output to the same as the [[BFS]]. To do so, we could expand the output 'levels'
list each time we arrive at a new level.

### Implementation

```java
class Solution {
    private List<List<Integer>> levels = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return levels;
        }

        bfs(root, 0);

        return levels;
    }

    private void bfs(TreeNode root, int level) {

        // reached a new level
        if (levels.size() == level) {
            levels.add(new ArrayList<Integer>());
        }

        levels.get(level).add(root.val);

        if (root.left != null) {
            bfs(root.left, level + 1);
        }

        if (root.right != null) {
            bfs(root.right, level + 1);
        }
    }
}
```

### Complexity Analysis

* **Time complexity:** $$O(N)$$.
* **Space complexity:** $$O(\log N)$$ for the best case and $$O(N)$$ for the worst case if the
output space is excluded.

## Approach 2: Iteration

### Algorithm

The [[recursion]] above could be rewritten in the [[iteration]] form.

Instead of doing the [[DFS]] and simulating as [[BFS]], we could use the `Queue` structure to do
[[BFS]] directly.

Visited all nodes in the level currently visit, and during the process add subtrees of the nodes to
the end of the queue.

```java

```

### Complexity Analysis

* **Time complexity:** $$O(N)$$.
* **Space complexity:** $$O(N)$$.
