---
description: Medium
---

# B 116. Populating Next Right Pointers in Each Node

## Description

## Approach 1: BFS \(Breadth-First Search\)

### Algorithm

This problem could be solved based on BFS. Connect node to next available node in queue except for the node that is the last one in the level.

### Implementation

```java
class Solution {
    public Node connect(Node root) {
        Queue<Node> nodes = new LinkedList<>();
        nodes.add(root);

        while (!nodes.isEmpty()) {
            int count = nodes.size();
            while (count-- > 0) {
                Node node = nodes.poll();

                if (node == null) {
                    break;
                }

                if (count > 0) {
                    node.next = nodes.peek();
                }

                nodes.add(node.left);
                nodes.add(node.right);
            }
        }

        return root;
    }
}
```

### Complexity Analysis

* **Time complexity:** $$O(N)$$.
* **Space complexty:** $$O(N)$$.

### Approach 2: Optimized BFS

### Algorithm

After we connect the node to its right node, we could navigate to the next node without using queue.

### Implementation

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Node head = root;
        Node curLevel = root.left;
        while (curLevel != null) {
            head.left.next = head.right;

            if (head.next == null) {
                head = curLevel;
                curLevel = head.left;
            } else {
                head.right.next = head.next.left;
                head = head.next;
            }
        }

        return root;
    }
}
```

### Complexity Analysis

* **Time complexity:** $$O(N)$$.
* **Space complextiy:** $$O(1)$$.

